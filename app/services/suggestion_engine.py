"""
DNA Suggestion Engine - Advisory signals based on odds/score changes.

Analyzes protocol state changes and generates actionable suggestions.
All suggestions are read-only — no auto-betting.
"""

from datetime import datetime
from typing import List, Dict, Optional
import uuid
from enum import Enum

from pydantic import BaseModel

from app.services.protocol_tracker import tracker, TrackedProtocol
from app.providers import OddsResponse, ScoreResponse


class SuggestionType(str, Enum):
    """Types of suggestions."""
    ODDS_MOVEMENT = "ODDS_MOVEMENT"
    SCORE_CHANGE = "SCORE_CHANGE"
    LINE_MOVEMENT = "LINE_MOVEMENT"
    PLAYER_SPIKE = "PLAYER_SPIKE"
    MARKET_CLOSING = "MARKET_CLOSING"


class SuggestionSeverity(str, Enum):
    """Suggestion severity levels."""
    INFO = "INFO"           # Informational
    NOTICE = "NOTICE"       # Worth noting
    ALERT = "ALERT"         # Significant change


class DNASuggestion(BaseModel):
    """A suggestion generated by the DNA engine."""
    id: str
    protocol_id: str
    type: SuggestionType
    severity: SuggestionSeverity
    message: str
    context: Dict
    timestamp: datetime
    acknowledged: bool = False
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }


# Configurable suggestion rules
SUGGESTION_RULES = {
    "spread_movement": {"threshold": 1.0, "severity": SuggestionSeverity.ALERT},
    "total_movement": {"threshold": 2.0, "severity": SuggestionSeverity.NOTICE},
    "score_spike": {"threshold": 10, "severity": SuggestionSeverity.INFO},
    "line_drop": {"threshold": 1.5, "severity": SuggestionSeverity.NOTICE},
}


class SuggestionEngine:
    """
    Analyzes protocol changes and generates suggestions.
    
    Thread-safe in-memory suggestion store.
    """
    
    _instance = None
    _suggestions: Dict[str, List[DNASuggestion]] = {}  # protocol_id -> suggestions
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def analyze_odds_change(
        self,
        protocol_id: str,
        old_odds: Optional[OddsResponse],
        new_odds: OddsResponse
    ) -> List[DNASuggestion]:
        """
        Analyze odds changes and generate suggestions.
        
        Args:
            protocol_id: Protocol being analyzed
            old_odds: Previous odds snapshot
            new_odds: Current odds snapshot
            
        Returns:
            List of generated suggestions
        """
        suggestions = []
        
        if not old_odds:
            return suggestions  # No previous data to compare
        
        # Check spread movement
        if new_odds.markets.spread and old_odds.markets.spread:
            old_home_line = old_odds.markets.spread["home"].line
            new_home_line = new_odds.markets.spread["home"].line
            delta = abs(new_home_line - old_home_line)
            
            if delta >= SUGGESTION_RULES["spread_movement"]["threshold"]:
                suggestion = DNASuggestion(
                    id=f"sug_{uuid.uuid4().hex[:8]}",
                    protocol_id=protocol_id,
                    type=SuggestionType.LINE_MOVEMENT,
                    severity=SUGGESTION_RULES["spread_movement"]["severity"],
                    message=f"Spread moved {delta:.1f} points ({old_home_line:.1f} → {new_home_line:.1f})",
                    context={
                        "market": "spread",
                        "old_value": old_home_line,
                        "new_value": new_home_line,
                        "delta": delta
                    },
                    timestamp=datetime.utcnow()
                )
                suggestions.append(suggestion)
        
        # Check total movement
        if new_odds.markets.total and old_odds.markets.total:
            old_line = old_odds.markets.total["over"].line
            new_line = new_odds.markets.total["over"].line
            delta = abs(new_line - old_line)
            
            if delta >= SUGGESTION_RULES["total_movement"]["threshold"]:
                direction = "up" if new_line > old_line else "down"
                suggestion = DNASuggestion(
                    id=f"sug_{uuid.uuid4().hex[:8]}",
                    protocol_id=protocol_id,
                    type=SuggestionType.LINE_MOVEMENT,
                    severity=SUGGESTION_RULES["total_movement"]["severity"],
                    message=f"Total moved {direction} {delta:.1f} points ({old_line:.1f} → {new_line:.1f})",
                    context={
                        "market": "total",
                        "old_value": old_line,
                        "new_value": new_line,
                        "delta": delta,
                        "direction": direction
                    },
                    timestamp=datetime.utcnow()
                )
                suggestions.append(suggestion)
        
        # Store suggestions
        if suggestions:
            if protocol_id not in self._suggestions:
                self._suggestions[protocol_id] = []
            self._suggestions[protocol_id].extend(suggestions)
        
        return suggestions
    
    def analyze_score_change(
        self,
        protocol_id: str,
        old_score: Optional[ScoreResponse],
        new_score: ScoreResponse
    ) -> List[DNASuggestion]:
        """Analyze score changes and generate suggestions."""
        suggestions = []
        
        if not old_score or not old_score.score or not new_score.score:
            return suggestions
        
        # Check for scoring spike
        old_total = old_score.score.home + old_score.score.away
        new_total = new_score.score.home + new_score.score.away
        delta = new_total - old_total
        
        if delta >= SUGGESTION_RULES["score_spike"]["threshold"]:
            suggestion = DNASuggestion(
                id=f"sug_{uuid.uuid4().hex[:8]}",
                protocol_id=protocol_id,
                type=SuggestionType.SCORE_CHANGE,
                severity=SUGGESTION_RULES["score_spike"]["severity"],
                message=f"High scoring detected: {delta} points in this period",
                context={
                    "old_total": old_total,
                    "new_total": new_total,
                    "delta": delta,
                    "quarter": new_score.quarter
                },
                timestamp=datetime.utcnow()
            )
            suggestions.append(suggestion)
            
            if protocol_id not in self._suggestions:
                self._suggestions[protocol_id] = []
            self._suggestions[protocol_id].append(suggestion)
        
        return suggestions
    
    def get_suggestions(
        self,
        protocol_id: str,
        unacknowledged_only: bool = False
    ) -> List[DNASuggestion]:
        """Get all suggestions for a protocol."""
        suggestions = self._suggestions.get(protocol_id, [])
        
        if unacknowledged_only:
            suggestions = [s for s in suggestions if not s.acknowledged]
        
        # Sort by timestamp desc (newest first)
        return sorted(suggestions, key=lambda s: s.timestamp, reverse=True)
    
    def acknowledge_suggestion(self, suggestion_id: str) -> bool:
        """Mark a suggestion as acknowledged (dismissed)."""
        for protocol_suggestions in self._suggestions.values():
            for suggestion in protocol_suggestions:
                if suggestion.id == suggestion_id:
                    suggestion.acknowledged = True
                    return True
        return False
    
    def clear_protocol_suggestions(self, protocol_id: str):
        """Clear all suggestions for a protocol."""
        if protocol_id in self._suggestions:
            del self._suggestions[protocol_id]


# Singleton instance
suggestion_engine = SuggestionEngine()
